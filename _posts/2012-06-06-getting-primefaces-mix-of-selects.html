---
layout: post
title: Getting PrimeFaces mix of Selects, Objects and Converters to work
date: '2012-06-06T20:35:00.001+01:00'
author: Igor Duarte Cardoso
tags:
- PrimeFaces
- Java
- JSF
modified_time: '2012-10-11T10:32:41.232+01:00'
blogger_id: tag:blogger.com,1999:blog-7503515668102711213.post-5247090870460204548
blogger_orig_url: http://igordcard.blogspot.com/2012/06/getting-primefaces-mix-of-selects.html
---

If you are having problems with the AJAX Select components from PrimeFaces when selecting Java objects, inside a DataTable or not, this solution might work for you.<br /><a name='more'></a><br />If you have something like the following: <br /><pre class="prettyprint">&lt;p:selectOneMenu value="#{deviceBean.currentLocation}"<br />                 converter="locationConverter"&gt;<br /><br />    &lt;f:selectItem itemLabel="#{deviceBean.currentLocation.name}"<br />                     itemValue="#{deviceBean.currentLocation}" /&gt;<br />    &lt;f:selectItems<br />        value="#{deviceBean.locations}"<br />        var="location"<br />        itemLabel="#{location.place}"<br />        itemValue="#{location}" /&gt;<br />    &lt;f:ajax event="change" execute="@this" render="@this" /&gt;<br /><br />&lt;/p:selectOneMenu&gt;</pre><div><br />Your managed bean is something like my <code>DeviceBean</code>:<br /><pre class="prettyprint">@ManagedBean<br />@SessionScoped<br />public class DeviceBean implements Serializable {<br /><br />    @EJB<br />    private Backend backend;<br /><br />    private List<location> locations;<br />    private Location currentLocation;<br /><br />    public DeviceBean() {<br />        locations = backend.getLocations();<br />    }<br /><br />    public List<location> getCurrentLocation() {<br />        return currentLocation;<br />    }<br /><br />    public Location getCurrentLocation() {<br />        return currentLocation;<br />    }<br />}<br /></location></location></pre><br />Your converter is something like:<br /><pre class="prettyprint">@FacesConverter(forClass=Location.class,value="locationConverter")<br />public class LocationConverter implements Converter {<br /><br />    @Override<br />    public Object getAsObject(FacesContext context, UIComponent component, String value) {<br />        Location location = new Location()<br />        // some operations to set the parameters of Location based on the String<br />        return location;<br />    }<br /><br />    @Override<br />    public String getAsString(FacesContext context, UIComponent component, Object value) {<br />        Location location = (Location) value;<br />        String string;<br />        // some operations to save the parameters of Location into a String<br />        return string;<br />    }<br />}<br /></pre><br />And the object you want to change is something like my <code>Location</code>:<br /><pre class="prettyprint">public class Location {<br />    private String name;<br /><br />    public String getName() {<br />        return name;<br />    }<br /><br />    public void setName(String name) {<br />        this.name = name;<br />    }<br />}<br /></pre><br /><br />And your Select doesn't work, e.g. it doesn't respond to the accept button nor gives any error or logging, then probably it's just discarding the new element you just selected (in my case, of type <code>Location</code>). <br /><br />It discards it because the object returned by the converter's <code>getAsObject</code> method may not match any of the objects allowed in the <code>locations</code> list from the <code>DeviceBean</code>. If this is the cause, then it means <code>Location</code> doesn't have proper <code>hashCode</code> and <code>equals</code> methods, which are required by Java to check if two objects of the same type have different contents or not, among other things. Because the <code>selectOneMenu</code> requires an object that is on the list, as defined in <code>value="#{deviceBean.currentLocation}"</code>, it just fails to do anything. <br /><br />So, don't forget, get <code>hashCode</code> and <code>equals</code> to the data structures you need to check for equality, explicitily or not, like this (as generated by my NetBeans): <br /><pre class="prettyprint">public class Location {<br />    private String name;<br /><br />    public String getName() {<br />        return name;<br />    }<br /><br />    public void setName(String name) {<br />        this.name = name;<br />    }<br /><br />    @Override<br />    public boolean equals(Object obj) {<br />        if(obj == null)<br />            return false;<br />        if(getClass() != obj.getClass())<br />            return false;<br />        final LocationTest other = (LocationTest)obj;<br />        if(!Objects.equals(this.name, other.name))<br />            return false;<br />        return true;<br />    }<br /><br />    @Override<br />    public int hashCode() {<br />        int hash = 7;<br />        hash = 83 * hash + Objects.hashCode(this.name);<br />        return hash;<br />    }<br />}<br /></pre></div>
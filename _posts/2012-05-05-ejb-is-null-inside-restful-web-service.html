---
layout: post
comments: true
title: EJB is null inside RESTful web service
date: '2012-05-05T21:11:00.002+01:00'
author: Igor Duarte Cardoso
tags:
- GlassFish
- EJB
- NetBeans
- Fixes
modified_time: '2012-05-09T10:28:40.465+01:00'
blogger_id: tag:blogger.com,1999:blog-7503515668102711213.post-3793663693933559715
blogger_orig_url: http://igordcard.blogspot.com/2012/05/ejb-is-null-inside-restful-web-service.html
---

While developing my enterprise application and learning Java EE at the same time, I came to a situation where injecting an EJB inside a RESTful web service class would be the same as nothing. The EJB variable was always <code>null</code>.<br /><br />So, what did I change to fix this?<br /><a name='more'></a>This was my source code before:<br /><pre class="prettyprint">@Path("/mypath")<br />public class MyREST {<br />    <br />    @EJB<br />    private MyFacadeLocal myFacade;<br />    <br />    public MyREST() {<br />    }<br /><br />    @GET<br />    @Produces("text/plain")<br />    public String respond() {        <br />        return "DONE";<br />    }<br />}<br /></pre>I forgot to tell the scope of the service. I managed to make it work by turning it request scoped (although from what I read it should be, by default, request scoped):  <br /><pre class="prettyprint">@RequestScoped<br />@Path("/mypath")<br />public class MyREST {<br />    <br />    @EJB<br />    private MyFacadeLocal myFacade;<br />    <br />    public MyREST() {<br />    }<br /><br />    @GET<br />    @Produces("text/plain")<br />    public String respond() {        <br />        return "DONE";<br />    }<br />}<br /></pre><br />If I make it session scoped, I end up with the issue: <a href="http://igordcard.blogspot.pt/2012/05/error-creating-managed-object-for-class.html">Error creating managed object for class</a>.<br /><br />If I make it @Stateless, it also works properly and seems to be the recommended way: <br /><pre class="prettyprint">@Stateless<br />@Path("/mypath")<br />public class MyREST {<br />    <br />    @EJB<br />    private MyFacadeLocal myFacade;<br />    <br />    public MyREST() {<br />    }<br /><br />    @GET<br />    @Produces("text/plain")<br />    public String respond() {        <br />        return "DONE";<br />    }<br />}<br /></pre><br />Notice that <code>MyFacadeLocal</code> is actually an interface for the session bean (which doesn't have the <code>@LocalBean</code> annotation itself). If I want to directly inject the session bean (called <code>MyFacade</code>) I need to have the <code>@LocalBean</code> annotation in it. If not, the EJB inside the RESTful web service may not be properly deployed and the following error may appear:<br /><pre style="border: 1px solid black;"><br />java.lang.IllegalStateException: Exception attempting to inject Remote ejb-ref name=rest.MyREST/myFacade,Remote 3.x interface =ejb.MyFacade,ejb-link=null,lookup=,mappedName=,jndi-name=ejb.MyFacade,refType=Session into class rest.MyREST: Lookup failed for 'java:comp/env/rest.MyREST/myFacade' in SerialContext[myEnv={java.naming.factory.initial=com.sun.enterprise.naming.impl.SerialInitContextFactory, java.naming.factory.state=com.sun.corba.ee.impl.presentation.rmi.JNDIStateFactoryImpl, java.naming.factory.url.pkgs=com.sun.enterprise.naming}<br /></pre><br />Here's MyFacade without requiring an interface (assuming you'll be using it locally anyway): <br /><pre class="prettyprint">@LocalBean<br />@Stateless<br />public class MyFacade extends AbstractFacade<my> {<br />    @PersistenceContext(unitName = "myjpaunit")<br />    private EntityManager em;<br /><br />    @Override<br />    protected EntityManager getEntityManager() {<br />        return em;<br />    }<br /><br />    public MyFacade() {<br />        super(My.class);<br />    }<br />    <br />    @Override<br />    public int count() {<br />        return super.count();<br />    }<br /><br />    @Override<br />    public void create(My entity) {<br />        super.create(entity);<br />    }<br /><br />    @Override<br />    public void edit(My entity) {<br />        super.edit(entity);<br />    }<br /><br />    @Override<br />    public My find(Object id) {<br />        return super.find(id);<br />    }<br /><br />    @Override<br />    public List<my> findAll() {<br />        return super.findAll();<br />    }<br /><br />    @Override<br />    public List<my> findRange(int[] range) {<br />        return super.findRange(range);<br />    }<br /><br />    @Override<br />    public void remove(My entity) {<br />        super.remove(entity);<br />    }<br />}<br /></pre><br />Another cause for having a null EJB is if, for any reason, an exception is thrown inside of it. Java EE will not inject it if running the EJB methods that are supposed to be called through the dependent object leads to exceptions. So, if you comment every call in your dependent object and then just check if the EJB is null, you'll see it isn't. But if you make use of a malfunctioning method, the EJB will just become null. <br /><b>Useful links:</b><br /><b><a href="http://stackoverflow.com/questions/8839824/ejb3-stateless-bean-is-always-null-in-rest-webservice-glassfish3-ejb3-statele">Glassfish embedded with JUnit for EJB testing</a></b>